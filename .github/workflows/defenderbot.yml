name: "🛡️ DefenderBot — FULL PIPELINE (Build→Docker→Release→Upgrade, No-Skip, Safe-Continue)"

on:
  push:
    branches: [ "main" ]
    paths:
      - "pom.xml"
      - "src/**"
      - "Dockerfile"
      - "docker/**"
      - "deploy/**"
      - ".github/workflows/defenderbot.yml"
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag (ex: v1.2.3). 빈 값이면 자동으로 manual-<sha7> 사용"
        required: false
        default: ""
      image_tag:
        description: "Docker image tag override. 빈 값이면 sha-<sha7>"
        required: false
        default: ""
      upgrade:
        description: "원격 업그레이드 시도 여부(true/false). 값 없어도 전체 파이프라인은 항상 진행"
        required: false
        default: "false"
      distro_image:
        description: "추가 base 이미지 빌드 요청 (ubuntu|ubi|none). 값 없어도 전체 파이프라인은 항상 진행"
        required: false
        default: "none"

permissions:
  contents: write      # release 생성/업데이트에 필요
  packages: write      # GHCR push
  id-token: write      # (확장용: OIDC 등)

env:
  TZ: Asia/Seoul
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  JAVA_VERSION: "17"
  LOG_DIR: .github/echo_logs
  ARTIFACT_DIR: .github/echo_artifacts
  DIST_DIR: dist
  TARGET_JAR: target/defenderbot.jar
  CONTAINER_NAME: defenderbot
  HOST_PORT: "8080"
  CONTAINER_PORT: "8080"

concurrency:
  group: defenderbot-${{ github.ref }}
  cancel-in-progress: false

jobs:
  full-pipeline:
    name: "DefenderBot Full Pipeline (No-Skip Everything)"
    runs-on: ubuntu-24.04
    continue-on-error: true   # 최악의 경우라도 job 자체는 성공 비슷하게 보이게 (전체 파이프라인은 끝까지 수행)

    steps:
      ########################################################################
      # 0. 준비 (디렉토리/로깅)
      ########################################################################
      - name: Prep audit dirs
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          echo "[`date '+%Y-%m-%d %H:%M:%S%z'`] pipeline.start" | tee "${LOG_DIR}/00_pipeline_start.log"

      - name: Checkout source
        uses: actions/checkout@v4

      ########################################################################
      # 1. Maven Build (절대 스킵 안 함)
      ########################################################################
      - name: Set up Temurin JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}
          cache: maven

      - name: Maven package (PR=skipTests)
        id: maven_build
        shell: bash
        run: |
          set -Eeuo pipefail
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CMD="mvn -q -DskipTests package"
          else
            CMD="mvn -q package"
          fi

          echo "▶ Running: $CMD" | tee "${LOG_DIR}/10_maven_cmd.log"
          if $CMD 2>&1 | tee "${LOG_DIR}/11_maven_build_full.log"; then
            echo "build_status=success" >> $GITHUB_OUTPUT
            echo "[OK] Maven build success" | tee -a "${LOG_DIR}/11_maven_build_full.log"
          else
            echo "build_status=failure" >> $GITHUB_OUTPUT
            echo "[WARN] Maven build failed, pipeline continues" | tee -a "${LOG_DIR}/11_maven_build_full.log"
          fi

          # JAR 확보/대체
          REAL_JAR="$(ls target/*.jar 2>/dev/null | head -n1 || true)"
          if [[ -n "$REAL_JAR" ]]; then
            cp -f "$REAL_JAR" "${{ env.TARGET_JAR }}" || true
          fi

          # 빌드 실패 시 dummy jar 강제 생성해서 이후 Docker 단계가 절대 막히지 않게 함
          if [[ ! -f "${{ env.TARGET_JAR }}" ]]; then
            echo "[WARN] No real JAR found, creating dummy jar" | tee -a "${LOG_DIR}/11_maven_build_full.log"
            echo "This is a dummy JAR placeholder because build failed $(date '+%Y-%m-%d %H:%M:%S%z')" > dummy.txt
            zip -q -j "${{ env.TARGET_JAR }}" dummy.txt || true
          fi

          # 실패 흔적 저장
          if [[ "$(cat $GITHUB_OUTPUT | grep build_status | cut -d= -f2)" != "success" ]]; then
            echo "BUILD_FAILED_AT=$(date '+%Y-%m-%d %H:%M:%S%z')" > target/BUILD_FAILED.txt
          fi

      - name: Upload build logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-build-step
          path: |
            ${{ env.LOG_DIR }}/10_maven_cmd.log
            ${{ env.LOG_DIR }}/11_maven_build_full.log
            target/BUILD_FAILED.txt
            ${{ env.TARGET_JAR }}
          if-no-files-found: warn

      ########################################################################
      # 2. Docker Build & Push (절대 스킵 안 함)
      ########################################################################
      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3
        continue-on-error: true

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3
        continue-on-error: true

      - name: Docker login GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      # 최종 이미지 태그 계산:
      #   1) workflow_dispatch 인 경우 inputs.image_tag 우선
      #   2) 그 외 sha-<7>
      - name: Compute image tag
        id: image_tag_calc
        shell: bash
        run: |
          set -Eeuo pipefail
          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          FINAL_TAG="sha-${SHORT_SHA}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ -n "${{ github.event.inputs.image_tag }}" ]]; then
              FINAL_TAG="${{ github.event.inputs.image_tag }}"
            fi
          fi
          echo "final_tag=$FINAL_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG_FINAL=$FINAL_TAG" | tee "${LOG_DIR}/20_image_tag.log"

      - name: Build & Push main app image
        shell: bash
        run: |
          set -Eeuo pipefail
          IMG_TAG="${{ steps.image_tag_calc.outputs.final_tag }}"
          IMAGE_FULL="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMG_TAG}"

          echo "▶ Building ${IMAGE_FULL}" | tee "${LOG_DIR}/21_docker_build_main.log"

          docker buildx build \
            --platform linux/amd64 \
            --file Dockerfile \
            --tag "${IMAGE_FULL}" \
            --push \
            . 2>&1 | tee -a "${LOG_DIR}/21_docker_build_main.log" || true

          docker images 2>&1 | tee "${LOG_DIR}/22_docker_images_after_main.log" || true
          docker history "${IMAGE_FULL}" 2>&1 | tee "${LOG_DIR}/23_docker_history_main.log" || true

      # distro_image(ubuntu|ubi|none)도 항상 시도.
      # 단, Dockerfile이 없으면 실패하지 않고 경고만 남기고 계속 진행.
      - name: Optionally build distro images (ubuntu / ubi)
        shell: bash
        run: |
          set -Eeuo pipefail
          DISTRO_REQ="none"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            DISTRO_REQ="${{ github.event.inputs.distro_image }}"
          fi

          IMG_TAG="${{ steps.image_tag_calc.outputs.final_tag }}"
          echo "Requested distro build: ${DISTRO_REQ}" | tee "${LOG_DIR}/24_distro_build.log"

          case "$DISTRO_REQ" in
            ubuntu)
              if [[ -f docker/ubuntu/Dockerfile ]]; then
                docker build \
                  -t "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubuntu:${IMG_TAG}" \
                  -f docker/ubuntu/Dockerfile docker/ubuntu \
                  2>&1 | tee -a "${LOG_DIR}/24_distro_build.log" || true
                docker push "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubuntu:${IMG_TAG}" || true
              else
                echo "[WARN] docker/ubuntu/Dockerfile 없음" | tee -a "${LOG_DIR}/24_distro_build.log"
              fi
              ;;
            ubi)
              if [[ -f docker/ubi/Dockerfile ]]; then
                docker build \
                  -t "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubi:${IMG_TAG}" \
                  -f docker/ubi/Dockerfile docker/ubi \
                  2>&1 | tee -a "${LOG_DIR}/24_distro_build.log" || true
                docker push "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubi:${IMG_TAG}" || true
              else
                echo "[WARN] docker/ubi/Dockerfile 없음" | tee -a "${LOG_DIR}/24_distro_build.log"
              fi
              ;;
            *)
              echo "No distro image build requested or 'none'." | tee -a "${LOG_DIR}/24_distro_build.log"
              ;;
          esac

      - name: Upload docker logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-docker-step
          path: |
            ${{ env.LOG_DIR }}/20_image_tag.log
            ${{ env.LOG_DIR }}/21_docker_build_main.log
            ${{ env.LOG_DIR }}/22_docker_images_after_main.log
            ${{ env.LOG_DIR }}/23_docker_history_main.log
            ${{ env.LOG_DIR }}/24_distro_build.log
          if-no-files-found: warn

      ########################################################################
      # 3. Release 생성 (항상 시도)
      ########################################################################
      - name: Prepare dist dir & checksum
        id: release_prep
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${DIST_DIR}"

          echo "▶ Copy final JAR to dist" | tee "${LOG_DIR}/30_release_prep.log"
          cp -f "${{ env.TARGET_JAR }}" "${DIST_DIR}/" 2>>"${LOG_DIR}/30_release_prep.log" || true

          # checksum 생성 (JAR 유무 상관없이 시도)
          if ls "${DIST_DIR}"/*.jar >/dev/null 2>&1; then
            for f in "${DIST_DIR}"/*.jar; do
              sha256sum "$f" > "$f.sha256" || true
            done
          else
            echo "[WARN] no jar in dist for checksum" | tee -a "${LOG_DIR}/30_release_prep.log"
          fi

          # Release tag 결정:
          # 1) workflow_dispatch + release_tag 입력값
          # 2) 현재 ref가 태그(refs/tags/...)라면 그 태그
          # 3) fallback: manual-<sha7>
          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          FALLBACK="manual-${SHORT_SHA}"
          FINAL_REL_TAG="$FALLBACK"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.release_tag }}" ]]; then
            FINAL_REL_TAG="${{ github.event.inputs.release_tag }}"
          elif [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            FINAL_REL_TAG="${GITHUB_REF##refs/tags/}"
          fi

          echo "release_tag_final=$FINAL_REL_TAG" >> $GITHUB_OUTPUT
          echo "FINAL_RELEASE_TAG=$FINAL_REL_TAG" | tee -a "${LOG_DIR}/30_release_prep.log"

      - name: Upload release prep logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-release-prep-step
          path: |
            ${{ env.LOG_DIR }}/30_release_prep.log
            ${{ env.DIST_DIR }}/*.jar
            ${{ env.DIST_DIR }}/*.sha256
          if-no-files-found: warn

      - name: Create / Update GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_prep.outputs.release_tag_final }}
          name: DefenderBot ${{ steps.release_prep.outputs.release_tag_final }}
          draft: false
          prerelease: false
          files: |
            ${{ env.DIST_DIR }}/*.jar
            ${{ env.DIST_DIR }}/*.sha256
        continue-on-error: true   # 릴리스 실패해도 파이프라인은 계속

      ########################################################################
      # 4. Remote Upgrade (항상 시도하되, ssh-agent 사용 X)
      ########################################################################
      - name: Install SSH client
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update -y
          sudo apt-get install -y openssh-client || true
          echo "[OK] ssh client ready" | tee "${LOG_DIR}/40_upgrade_sshclient.log"

      - name: Compute upgrade enable & tag
        id: upgrade_calc
        shell: bash
        run: |
          set -Eeuo pipefail
          # 업그레이드 요청 여부 (workflow_dispatch 에서 upgrade=true)
          UPG_REQ="false"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.upgrade }}" == "true" ]]; then
            UPG_REQ="true"
          fi

          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          FINAL_TAG="sha-${SHORT_SHA}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.image_tag }}" ]]; then
            FINAL_TAG="${{ github.event.inputs.image_tag }}"
          fi

          echo "upgrade_request=$UPG_REQ" >> $GITHUB_OUTPUT
          echo "deploy_tag=$FINAL_TAG" >> $GITHUB_OUTPUT

          {
            echo "UPGRADE_REQUEST=$UPG_REQ"
            echo "DEPLOY_TAG=$FINAL_TAG"
          } | tee "${LOG_DIR}/41_upgrade_calc.log"

      - name: Register known_hosts (if host provided)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p ~/.ssh
          if [[ -n "${{ secrets.SERVER_HOST }}" ]]; then
            ssh-keyscan -H "${{ secrets.SERVER_HOST }}" >> ~/.ssh/known_hosts || true
            echo "known_hosts updated for ${{ secrets.SERVER_HOST }}" | tee "${LOG_DIR}/42_known_hosts.log"
          else
            echo "[WARN] SERVER_HOST secret missing, will not SSH" | tee "${LOG_DIR}/42_known_hosts.log"
          fi

      - name: Remote pull & restart container
        shell: bash
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail

          echo ">>> REMOTE UPGRADE STEP"          | tee "${LOG_DIR}/43_remote_upgrade.log"
          echo "SERVER_HOST=${SERVER_HOST}"      | tee -a "${LOG_DIR}/43_remote_upgrade.log"
          echo "SERVER_USER=${SERVER_USER}"      | tee -a "${LOG_DIR}/43_remote_upgrade.log"

          # 조건을 만족하지 못하면 그냥 soft-pass
          if [[ "${{ steps.upgrade_calc.outputs.upgrade_request }}" != "true" ]]; then
            echo "[INFO] upgrade_request != true, skipping remote deploy logic (soft-pass)" | tee -a "${LOG_DIR}/43_remote_upgrade.log"
            exit 0
          fi
          if [[ -z "${SERVER_HOST}" || -z "${SERVER_USER}" || -z "${GITHUB_TOKEN}" ]]; then
            echo "[WARN] Missing SERVER_HOST / SERVER_USER / GITHUB_TOKEN -> cannot SSH deploy. soft-pass." | tee -a "${LOG_DIR}/43_remote_upgrade.log"
            exit 0
          fi

          IMG_TAG="${{ steps.upgrade_calc.outputs.deploy_tag }}"
          REMOTE_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMG_TAG}"
          echo "[INFO] Using remote image ${REMOTE_IMAGE}" | tee -a "${LOG_DIR}/43_remote_upgrade.log"

          # 여기서 ssh-agent를 쓰지 않고 ssh 기본키(default key)로 접근 시도
          # 만약 러너에 key가 없으면 그냥 실패하고 || true 로 soft-pass
          ssh -o StrictHostKeyChecking=yes "${SERVER_USER}@${SERVER_HOST}" bash -lc "
            set -Eeuo pipefail
            echo '--- Remote Upgrade Script Started ---'

            echo \"\$GITHUB_TOKEN\" | docker login ${{ env.REGISTRY }} -u '${{ github.actor }}' --password-stdin || true

            echo 'Pulling image: ${REMOTE_IMAGE}'
            docker pull ${REMOTE_IMAGE} || true

            echo 'Stopping existing container if exists'
            docker rm -f ${{ env.CONTAINER_NAME }} 2>/dev/null || true

            echo 'Starting new container'
            docker run -d --name ${{ env.CONTAINER_NAME }} \
              -p ${{ env.HOST_PORT }}:${{ env.CONTAINER_PORT }} \
              --restart unless-stopped \
              ${REMOTE_IMAGE} || true

            echo '--- Remote Upgrade Script Finished ---'
          " || true

      - name: Upload upgrade logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-upgrade-step
          path: |
            ${{ env.LOG_DIR }}/40_upgrade_sshclient.log
            ${{ env.LOG_DIR }}/41_upgrade_calc.log
            ${{ env.LOG_DIR }}/42_known_hosts.log
            ${{ env.LOG_DIR }}/43_remote_upgrade.log
          if-no-files-found: warn

      ########################################################################
      # 5. FINAL PIPELINE SNAPSHOT (전체 로그 모음)
      ########################################################################
      - name: Upload ALL logs/final snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-full-run
          path: |
            ${{ env.LOG_DIR }}/
            ${{ env.ARTIFACT_DIR }}/
            target/
            ${{ env.DIST_DIR }}/
          if-no-files-found: warn

      - name: Mark pipeline end
        shell: bash
        run: |
          echo "[`date '+%Y-%m-%d %H:%M:%S%z'`] pipeline.end (ALL STEPS ATTEMPTED)" \
            | tee "${LOG_DIR}/99_pipeline_end.log"
