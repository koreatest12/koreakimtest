name: "🛡️ DefenderBot — FULL PIPELINE (Build→Docker→Release→Upgrade, No-Skip, Safe-Continue, Stable Dirs)"

on:
  push:
    branches: [ "main" ]
    paths:
      - "pom.xml"
      - "src/**"
      - "Dockerfile"
      - "docker/**"
      - "deploy/**"
      - ".github/workflows/defenderbot.yml"
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag (ex: v1.2.3). 빈 값이면 manual-<sha7>"
        required: false
        default: ""
      image_tag:
        description: "Docker image tag override. 빈 값이면 sha-<sha7>"
        required: false
        default: ""
      upgrade:
        description: "원격 업그레이드 시도 여부(true/false). 없어도 전체 파이프라인은 항상 진행"
        required: false
        default: "false"
      distro_image:
        description: "추가 base 이미지 빌드 (ubuntu|ubi|none)"
        required: false
        default: "none"

permissions:
  contents: write      # GH Release에 필요
  packages: write      # GHCR push에 필요
  id-token: write      # (확장용: OIDC 등)

env:
  TZ: Asia/Seoul
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  JAVA_VERSION: "17"
  LOG_DIR: .github/echo_logs
  ARTIFACT_DIR: .github/echo_artifacts
  DIST_DIR: dist
  TARGET_JAR: target/defenderbot.jar
  CONTAINER_NAME: defenderbot
  HOST_PORT: "8080"
  CONTAINER_PORT: "8080"

concurrency:
  group: defenderbot-${{ github.ref }}
  cancel-in-progress: false

jobs:
  full-pipeline:
    name: "DefenderBot Full Pipeline (No-Skip Everything)"
    runs-on: ubuntu-24.04
    continue-on-error: true   # 최악이어도 job 자체는 녹색에 가깝게 유지

    steps:
      ########################################################################
      # 0. Checkout 먼저 (중요: .github 디렉토리 덮어쓰기로 우리가 만든 폴더 사라지는 문제 방지)
      ########################################################################
      - name: Checkout source
        uses: actions/checkout@v4

      ########################################################################
      # 1. 공용 디렉토리 준비 (checkout 이후에 반드시 다시 mkdir -p!!)
      ########################################################################
      - name: Prep audit dirs (post-checkout)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          echo "[`date '+%Y-%m-%d %H:%M:%S%z'`] pipeline.start" | tee "${LOG_DIR}/00_pipeline_start.log"
          # 업로드 경로에 최소 .keep 파일도 만들어둠
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

      ########################################################################
      # 2. Maven Build
      ########################################################################
      - name: Set up Temurin JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}
          cache: maven

      - name: Maven package (PR=skipTests)
        id: maven_build
        shell: bash
        run: |
          set -Eeuo pipefail
          # 디렉토리 보강 (혹시라도 이전 단계에서 누락되거나 나중에 뭔가가 지워졌어도 다시 생성)
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CMD="mvn -q -DskipTests package"
          else
            CMD="mvn -q package"
          fi

          echo "▶ Running: $CMD" | tee "${LOG_DIR}/10_maven_cmd.log"

          if $CMD 2>&1 | tee "${LOG_DIR}/11_maven_build_full.log"; then
            echo "build_status=success" >> $GITHUB_OUTPUT
            echo "[OK] Maven build success" | tee -a "${LOG_DIR}/11_maven_build_full.log"
          else
            echo "build_status=failure" >> $GITHUB_OUTPUT
            echo "[WARN] Maven build failed, pipeline continues" | tee -a "${LOG_DIR}/11_maven_build_full.log"
          fi

          # jar 산출물 확보
          REAL_JAR="$(ls target/*.jar 2>/dev/null | head -n1 || true)"
          if [[ -n "$REAL_JAR" ]]; then
            cp -f "$REAL_JAR" "${{ env.TARGET_JAR }}" || true
          fi

          # 빌드 실패해도 docker 단계가 깨지지 않도록 dummy jar 생성
          if [[ ! -f "${{ env.TARGET_JAR }}" ]]; then
            echo "[WARN] No real JAR found, creating dummy jar" | tee -a "${LOG_DIR}/11_maven_build_full.log"
            echo "Dummy JAR placeholder because build failed $(date '+%Y-%m-%d %H:%M:%S%z')" > dummy.txt
            zip -q -j "${{ env.TARGET_JAR }}" dummy.txt || true
          fi

          # 실패 흔적 파일
          if [[ "$(cat $GITHUB_OUTPUT | grep build_status | cut -d= -f2)" != "success" ]]; then
            echo "BUILD_FAILED_AT=$(date '+%Y-%m-%d %H:%M:%S%z')" > target/BUILD_FAILED.txt
          fi

          # 안전하게 .keep 다시
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

      - name: Upload build logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-build-step
          path: |
            ${{ env.LOG_DIR }}/10_maven_cmd.log
            ${{ env.LOG_DIR }}/11_maven_build_full.log
            ${{ env.LOG_DIR }}/.keep
            target/BUILD_FAILED.txt
            target/.keep
            ${{ env.TARGET_JAR }}
          if-no-files-found: warn

      ########################################################################
      # 3. Docker Build & Push
      ########################################################################
      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3
        continue-on-error: true

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3
        continue-on-error: true

      - name: Docker login GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Compute image tag
        id: image_tag_calc
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          FINAL_TAG="sha-${SHORT_SHA}"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.image_tag }}" ]]; then
            FINAL_TAG="${{ github.event.inputs.image_tag }}"
          fi

          echo "final_tag=$FINAL_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG_FINAL=$FINAL_TAG" | tee "${LOG_DIR}/20_image_tag.log"

      - name: Build & Push main app image
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

          IMG_TAG="${{ steps.image_tag_calc.outputs.final_tag }}"
          IMAGE_FULL="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMG_TAG}"

          echo "▶ Building ${IMAGE_FULL}" | tee "${LOG_DIR}/21_docker_build_main.log"

          docker buildx build \
            --platform linux/amd64 \
            --file Dockerfile \
            --tag "${IMAGE_FULL}" \
            --push \
            . 2>&1 | tee -a "${LOG_DIR}/21_docker_build_main.log" || true

          docker images 2>&1 | tee "${LOG_DIR}/22_docker_images_after_main.log" || true
          docker history "${IMAGE_FULL}" 2>&1 | tee "${LOG_DIR}/23_docker_history_main.log" || true

      - name: Optionally build distro images (ubuntu / ubi)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

          DISTRO_REQ="none"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            DISTRO_REQ="${{ github.event.inputs.distro_image }}"
          fi

          IMG_TAG="${{ steps.image_tag_calc.outputs.final_tag }}"
          echo "Requested distro build: ${DISTRO_REQ}" | tee "${LOG_DIR}/24_distro_build.log"

          case "$DISTRO_REQ" in
            ubuntu)
              if [[ -f docker/ubuntu/Dockerfile ]]; then
                docker build \
                  -t "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubuntu:${IMG_TAG}" \
                  -f docker/ubuntu/Dockerfile docker/ubuntu \
                  2>&1 | tee -a "${LOG_DIR}/24_distro_build.log" || true
                docker push "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubuntu:${IMG_TAG}" || true
              else
                echo "[WARN] docker/ubuntu/Dockerfile 없음" | tee -a "${LOG_DIR}/24_distro_build.log"
              fi
              ;;
            ubi)
              if [[ -f docker/ubi/Dockerfile ]]; then
                docker build \
                  -t "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubi:${IMG_TAG}" \
                  -f docker/ubi/Dockerfile docker/ubi \
                  2>&1 | tee -a "${LOG_DIR}/24_distro_build.log" || true
                docker push "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubi:${IMG_TAG}" || true
              else
                echo "[WARN] docker/ubi/Dockerfile 없음" | tee -a "${LOG_DIR}/24_distro_build.log"
              fi
              ;;
            *)
              echo "No distro image build requested or 'none'." | tee -a "${LOG_DIR}/24_distro_build.log"
              ;;
          esac

      - name: Upload docker logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-docker-step
          path: |
            ${{ env.LOG_DIR }}/20_image_tag.log
            ${{ env.LOG_DIR }}/21_docker_build_main.log
            ${{ env.LOG_DIR }}/22_docker_images_after_main.log
            ${{ env.LOG_DIR }}/23_docker_history_main.log
            ${{ env.LOG_DIR }}/24_distro_build.log
            ${{ env.LOG_DIR }}/.keep
          if-no-files-found: warn

      ########################################################################
      # 4. Release 생성
      ########################################################################
      - name: Prepare dist dir & checksum
        id: release_prep
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

          echo "▶ Copy final JAR to dist" | tee "${LOG_DIR}/30_release_prep.log"
          cp -f "${{ env.TARGET_JAR }}" "${DIST_DIR}/" 2>>"${LOG_DIR}/30_release_prep.log" || true

          if ls "${DIST_DIR}"/*.jar >/dev/null 2>&1; then
            for f in "${DIST_DIR}"/*.jar; do
              sha256sum "$f" > "$f.sha256" || true
            done
          else
            echo "[WARN] no jar in dist for checksum" | tee -a "${LOG_DIR}/30_release_prep.log"
          fi

          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          FALLBACK="manual-${SHORT_SHA}"
          FINAL_REL_TAG="$FALLBACK"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.release_tag }}" ]]; then
            FINAL_REL_TAG="${{ github.event.inputs.release_tag }}"
          elif [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            FINAL_REL_TAG="${GITHUB_REF##refs/tags/}"
          fi

          echo "release_tag_final=$FINAL_REL_TAG" >> $GITHUB_OUTPUT
          echo "FINAL_RELEASE_TAG=$FINAL_REL_TAG" | tee -a "${LOG_DIR}/30_release_prep.log"

      - name: Upload release prep logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-release-prep-step
          path: |
            ${{ env.LOG_DIR }}/30_release_prep.log
            ${{ env.LOG_DIR }}/.keep
            ${{ env.DIST_DIR }}/*.jar
            ${{ env.DIST_DIR }}/*.sha256
            ${{ env.DIST_DIR }}/.keep
          if-no-files-found: warn

      - name: Create / Update GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_prep.outputs.release_tag_final }}
          name: DefenderBot ${{ steps.release_prep.outputs.release_tag_final }}
          draft: false
          prerelease: false
          files: |
            ${{ env.DIST_DIR }}/*.jar
            ${{ env.DIST_DIR }}/*.sha256
        continue-on-error: true   # 릴리스 실패해도 계속

      ########################################################################
      # 5. Remote Upgrade (ssh-agent 없이, 항상 시도하되 soft-pass)
      ########################################################################
      - name: Install SSH client
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update -y
          sudo apt-get install -y openssh-client || true
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep
          echo "[OK] ssh client ready" | tee "${LOG_DIR}/40_upgrade_sshclient.log"

      - name: Compute upgrade enable & tag
        id: upgrade_calc
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

          UPG_REQ="false"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.upgrade }}" == "true" ]]; then
            UPG_REQ="true"
          fi

          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          FINAL_TAG="sha-${SHORT_SHA}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.image_tag }}" ]]; then
            FINAL_TAG="${{ github.event.inputs.image_tag }}"
          fi

          echo "upgrade_request=$UPG_REQ" >> $GITHUB_OUTPUT
          echo "deploy_tag=$FINAL_TAG" >> $GITHUB_OUTPUT

          {
            echo "UPGRADE_REQUEST=$UPG_REQ"
            echo "DEPLOY_TAG=$FINAL_TAG"
          } | tee "${LOG_DIR}/41_upgrade_calc.log"

      - name: Register known_hosts (if host provided)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p ~/.ssh
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

          if [[ -n "${{ secrets.SERVER_HOST }}" ]]; then
            ssh-keyscan -H "${{ secrets.SERVER_HOST }}" >> ~/.ssh/known_hosts || true
            echo "known_hosts updated for ${{ secrets.SERVER_HOST }}" | tee "${LOG_DIR}/42_known_hosts.log"
          else
            echo "[WARN] SERVER_HOST secret missing, will not SSH" | tee "${LOG_DIR}/42_known_hosts.log"
          fi

      - name: Remote pull & restart container
        shell: bash
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

          echo ">>> REMOTE UPGRADE STEP"          | tee "${LOG_DIR}/43_remote_upgrade.log"
          echo "SERVER_HOST=${SERVER_HOST}"      | tee -a "${LOG_DIR}/43_remote_upgrade.log"
          echo "SERVER_USER=${SERVER_USER}"      | tee -a "${LOG_DIR}/43_remote_upgrade.log"

          if [[ "${{ steps.upgrade_calc.outputs.upgrade_request }}" != "true" ]]; then
            echo "[INFO] upgrade_request != true, soft-pass" | tee -a "${LOG_DIR}/43_remote_upgrade.log"
            exit 0
          fi
          if [[ -z "${SERVER_HOST}" || -z "${SERVER_USER}" || -z "${GITHUB_TOKEN}" ]]; then
            echo "[WARN] Missing SERVER_HOST / SERVER_USER / GITHUB_TOKEN -> cannot SSH deploy. soft-pass." | tee -a "${LOG_DIR}/43_remote_upgrade.log"
            exit 0
          fi

          IMG_TAG="${{ steps.upgrade_calc.outputs.deploy_tag }}"
          REMOTE_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMG_TAG}"
          echo "[INFO] Using remote image ${REMOTE_IMAGE}" | tee -a "${LOG_DIR}/43_remote_upgrade.log"

          # ssh-agent 없이 기본 ssh 키로만 시도. 실패해도 || true 로 계속.
          ssh -o StrictHostKeyChecking=yes "${SERVER_USER}@${SERVER_HOST}" bash -lc "
            set -Eeuo pipefail
            echo '--- Remote Upgrade Script Started ---'

            echo \"\$GITHUB_TOKEN\" | docker login ${{ env.REGISTRY }} -u '${{ github.actor }}' --password-stdin || true

            echo 'Pulling image: ${REMOTE_IMAGE}'
            docker pull ${REMOTE_IMAGE} || true

            echo 'Stopping existing container if exists'
            docker rm -f ${{ env.CONTAINER_NAME }} 2>/dev/null || true

            echo 'Starting new container'
            docker run -d --name ${{ env.CONTAINER_NAME }} \
              -p ${{ env.HOST_PORT }}:${{ env.CONTAINER_PORT }} \
              --restart unless-stopped \
              ${REMOTE_IMAGE} || true

            echo '--- Remote Upgrade Script Finished ---'
          " || true

      - name: Upload upgrade logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-upgrade-step
          path: |
            ${{ env.LOG_DIR }}/40_upgrade_sshclient.log
            ${{ env.LOG_DIR }}/41_upgrade_calc.log
            ${{ env.LOG_DIR }}/42_known_hosts.log
            ${{ env.LOG_DIR }}/43_remote_upgrade.log
            ${{ env.LOG_DIR }}/.keep
          if-no-files-found: warn

      ########################################################################
      # 6. FINAL PIPELINE SNAPSHOT (모든 것)
      ########################################################################
      - name: Final ensure dirs + .keep
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep
          echo "[`date '+%Y-%m-%d %H:%M:%S%z'`] pipeline.end (ALL STEPS ATTEMPTED)" \
            | tee "${LOG_DIR}/99_pipeline_end.log"

      - name: Upload ALL logs/final snapshot
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: defenderbot-full-run
          path: |
            ${{ env.LOG_DIR }}/
            ${{ env.ARTIFACT_DIR }}/
            ${{ env.DIST_DIR }}/
            target/
          if-no-files-found: warn
