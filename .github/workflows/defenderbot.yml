name: "🛡️ DefenderBot — FULL PIPELINE (Build→Docker→Release→Upgrade, No-Skip, Safe-Continue, Audit+RunnerDump)"

on:
  push:
    branches: [ "main" ]
    paths:
      - "pom.xml"
      - "src/**"
      - "Dockerfile"
      - "docker/**"
      - "deploy/**"
      - ".github/workflows/defenderbot.yml"
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag (ex: v1.2.3). 빈 값이면 manual-<sha7>"
        required: false
        default: ""
      image_tag:
        description: "Docker image tag override. 빈 값이면 sha-<sha7>"
        required: false
        default: ""
      upgrade:
        description: "원격 업그레이드 시도 여부(true/false). 없어도 전체 파이프라인은 항상 진행"
        required: false
        default: "false"
      distro_image:
        description: "추가 base 이미지 빌드 (ubuntu|ubi|none)"
        required: false
        default: "none"

permissions:
  contents: write      # GH Release
  packages: write      # GHCR push
  id-token: write      # (확장: OIDC 등)

env:
  TZ: Asia/Seoul
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  JAVA_VERSION: "17"

  LOG_DIR: .github/echo_logs
  ARTIFACT_DIR: .github/echo_artifacts
  DIST_DIR: dist
  TARGET_JAR: target/defenderbot.jar

  CONTAINER_NAME: defenderbot
  HOST_PORT: "8080"
  CONTAINER_PORT: "8080"

concurrency:
  group: defenderbot-${{ github.ref }}
  cancel-in-progress: false

jobs:
  full-pipeline:
    name: "DefenderBot Full Pipeline (No-Skip Everything + Audit)"
    runs-on: ubuntu-24.04
    continue-on-error: true

    steps:
      ########################################################################
      # 0. Checkout 먼저 (중요: checkout이 .github 디렉토리 덮어쓰므로 mkdir은 checkout 이후에!)
      ########################################################################
      - name: Checkout source
        uses: actions/checkout@v4

      ########################################################################
      # 1. 공용 디렉토리 준비 + 컨텍스트/러너 상태 덤프 (운영 감사용)
      ########################################################################
      - name: Prep dirs / dump context / runner snapshot
        shell: bash
        run: |
          set -Eeuo pipefail

          # 필수 디렉토리/keep 파일 준비
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

          # 파이프라인 시작 로그
          echo "[`date '+%Y-%m-%d %H:%M:%S%z'`] pipeline.start" | tee "${LOG_DIR}/00_pipeline_start.log"

          # 실행 컨텍스트 요약 저장 (누가/언제/어떤 브랜치/어떤 SHA)
          {
            echo "=== PIPELINE CONTEXT DUMP ==="
            echo "EVENT_NAME=${{ github.event_name }}"
            echo "REPO=${{ github.repository }}"
            echo "REF=${{ github.ref }}"
            echo "SHA=${{ github.sha }}"
            echo "ACTOR=${{ github.actor }}"
            echo "RUN_ID=${{ github.run_id }}"
            echo "RUN_NUMBER=${{ github.run_number }}"
            echo "WORKFLOW=${{ github.workflow }}"
            echo "TZ=$TZ"
            echo "-----------------------------"
            env | sort
          } | tee "${LOG_DIR}/01_context_dump.log"

          # 러너/환경 스냅샷 (빌드 전 상태 기록)
          {
            echo "=== RUNNER SNAPSHOT (BEFORE BUILD) ==="
            echo "--- uname -a"
            uname -a || true
            echo
            echo "--- lsb_release -a"
            lsb_release -a || true
            echo
            echo "--- df -h"
            df -h || true
            echo
            echo "--- free -m"
            free -m || true
            echo
            echo "--- docker version"
            docker version || true
            echo
            echo "--- docker info"
            docker info || true
            echo
            echo "--- whoami / pwd"
            whoami || true
            pwd || true
            echo
          } | tee "${LOG_DIR}/02_runner_snapshot_prebuild.log"

      ########################################################################
      # 2. Maven Build (절대 중단 안 함, 실패해도 dummy JAR 강제 생성)
      ########################################################################
      - name: Set up Temurin JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ env.JAVA_VERSION }}
          cache: maven

      - name: Maven package (PR=skipTests)
        id: maven_build
        shell: bash
        run: |
          set -Eeuo pipefail
          # (방어적) 디렉토리 다시 보강
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            CMD="mvn -q -DskipTests package"
          else
            CMD="mvn -q package"
          fi

          echo "▶ Running: $CMD" | tee "${LOG_DIR}/10_maven_cmd.log"

          if $CMD 2>&1 | tee "${LOG_DIR}/11_maven_build_full.log"; then
            echo "build_status=success" >> $GITHUB_OUTPUT
            echo "[OK] Maven build success" | tee -a "${LOG_DIR}/11_maven_build_full.log"
          else
            echo "build_status=failure" >> $GITHUB_OUTPUT
            echo "[WARN] Maven build failed, pipeline continues" | tee -a "${LOG_DIR}/11_maven_build_full.log"
          fi

          # jar 산출물 확보
          REAL_JAR="$(ls target/*.jar 2>/dev/null | head -n1 || true)"
          if [[ -n "$REAL_JAR" ]]; then
            cp -f "$REAL_JAR" "${{ env.TARGET_JAR }}" || true
          fi

          # 실패 시 dummy jar 생성 (후속 docker 단계가 절대 멈추지 않게)
          if [[ ! -f "${{ env.TARGET_JAR }}" ]]; then
            echo "[WARN] No real JAR found, creating dummy jar" | tee -a "${LOG_DIR}/11_maven_build_full.log"
            echo "Dummy JAR placeholder (build failed) $(date '+%Y-%m-%d %H:%M:%S%z')" > dummy.txt
            zip -q -j "${{ env.TARGET_JAR }}" dummy.txt || true
          fi

          # 실패 흔적
          if [[ "$(cat $GITHUB_OUTPUT | grep build_status | cut -d= -f2)" != "success" ]]; then
            echo "BUILD_FAILED_AT=$(date '+%Y-%m-%d %H:%M:%S%z')" > target/BUILD_FAILED.txt
          fi

          # 나중 업로드를 위해 keep 보강
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

      - name: Upload build logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: defenderbot-build-step
          path: |
            ${{ env.LOG_DIR }}/00_pipeline_start.log
            ${{ env.LOG_DIR }}/01_context_dump.log
            ${{ env.LOG_DIR }}/02_runner_snapshot_prebuild.log
            ${{ env.LOG_DIR }}/10_maven_cmd.log
            ${{ env.LOG_DIR }}/11_maven_build_full.log
            ${{ env.LOG_DIR }}/.keep
            target/BUILD_FAILED.txt
            target/.keep
            ${{ env.TARGET_JAR }}
          if-no-files-found: warn

      ########################################################################
      # 3. Docker Build & Push (이미지 빌드, 태그 계산, 헬스체크까지 시도)
      ########################################################################
      - name: Setup QEMU
        uses: docker/setup-qemu-action@v3
        continue-on-error: true

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3
        continue-on-error: true

      - name: Docker login GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Compute image tag
        id: image_tag_calc
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          FINAL_TAG="sha-${SHORT_SHA}"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.image_tag }}" ]]; then
            FINAL_TAG="${{ github.event.inputs.image_tag }}"
          fi

          echo "final_tag=$FINAL_TAG" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG_FINAL=$FINAL_TAG" | tee "${LOG_DIR}/20_image_tag.log"

      - name: Build & Push main app image
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

          IMG_TAG="${{ steps.image_tag_calc.outputs.final_tag }}"
          IMAGE_FULL="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMG_TAG}"

          echo "▶ Building ${IMAGE_FULL}" | tee "${LOG_DIR}/21_docker_build_main.log"

          docker buildx build \
            --platform linux/amd64 \
            --file Dockerfile \
            --tag "${IMAGE_FULL}" \
            --push \
            . 2>&1 | tee -a "${LOG_DIR}/21_docker_build_main.log" || true

          docker images 2>&1 | tee "${LOG_DIR}/22_docker_images_after_main.log" || true
          docker history "${IMAGE_FULL}" 2>&1 | tee "${LOG_DIR}/23_docker_history_main.log" || true

      - name: Docker container healthcheck (run/exit test)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}"
          touch "${LOG_DIR}/.keep"

          IMG_TAG="${{ steps.image_tag_calc.outputs.final_tag }}"
          IMAGE_FULL="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMG_TAG}"

          echo "▶ Smoke run container for ${IMAGE_FULL}" | tee "${LOG_DIR}/23b_docker_healthcheck.log"
          # 여기서는 단순하게 컨테이너 한 번 띄워보고 java -version 비슷한 동작만 시도.
          # Spring Boot app이라 바로 종료 안 할 수도 있지만 어쨌든 시도만: 실패해도 true 처리
          docker run --rm "${IMAGE_FULL}" java -version \
            2>&1 | tee -a "${LOG_DIR}/23b_docker_healthcheck.log" || true

      - name: Optionally build distro images (ubuntu / ubi)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" target "${DIST_DIR}"
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" target/.keep "${DIST_DIR}/.keep"

          DISTRO_REQ="none"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            DISTRO_REQ="${{ github.event.inputs.distro_image }}"
          fi

          IMG_TAG="${{ steps.image_tag_calc.outputs.final_tag }}"
          echo "Requested distro build: ${DISTRO_REQ}" | tee "${LOG_DIR}/24_distro_build.log"

          case "$DISTRO_REQ" in
            ubuntu)
              if [[ -f docker/ubuntu/Dockerfile ]]; then
                docker build \
                  -t "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubuntu:${IMG_TAG}" \
                  -f docker/ubuntu/Dockerfile docker/ubuntu \
                  2>&1 | tee -a "${LOG_DIR}/24_distro_build.log" || true
                docker push "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubuntu:${IMG_TAG}" || true
              else
                echo "[WARN] docker/ubuntu/Dockerfile 없음" | tee -a "${LOG_DIR}/24_distro_build.log"
              fi
              ;;
            ubi)
              if [[ -f docker/ubi/Dockerfile ]]; then
                docker build \
                  -t "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubi:${IMG_TAG}" \
                  -f docker/ubi/Dockerfile docker/ubi \
                  2>&1 | tee -a "${LOG_DIR}/24_distro_build.log" || true
                docker push "${{ env.REGISTRY }}/${{ github.repository_owner }}/ubi:${IMG_TAG}" || true
              else
                echo "[WARN] docker/ubi/Dockerfile 없음" | tee -a "${LOG_DIR}/24_distro_build.log"
              fi
              ;;
            *)
              echo "No distro image build requested or 'none'." | tee -a "${LOG_DIR}/24_distro_build.log"
              ;;
          esac

      - name: Upload docker logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: defenderbot-docker-step
          path: |
            ${{ env.LOG_DIR }}/20_image_tag.log
            ${{ env.LOG_DIR }}/21_docker_build_main.log
            ${{ env.LOG_DIR }}/22_docker_images_after_main.log
            ${{ env.LOG_DIR }}/23_docker_history_main.log
            ${{ env.LOG_DIR }}/23b_docker_healthcheck.log
            ${{ env.LOG_DIR }}/24_distro_build.log
            ${{ env.LOG_DIR }}/.keep
          if-no-files-found: warn

      ########################################################################
      # 4. Release 생성 (항상 시도, 태그 없으면 manual-<sha7>)
      ########################################################################
      - name: Prepare dist dir & checksum
        id: release_prep
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

          echo "▶ Copy final JAR to dist" | tee "${LOG_DIR}/30_release_prep.log"
          cp -f "${{ env.TARGET_JAR }}" "${DIST_DIR}/" 2>>"${LOG_DIR}/30_release_prep.log" || true

          if ls "${DIST_DIR}"/*.jar >/dev/null 2>&1; then
            for f in "${DIST_DIR}"/*.jar; do
              sha256sum "$f" > "$f.sha256" || true
            done
          else
            echo "[WARN] no jar in dist for checksum" | tee -a "${LOG_DIR}/30_release_prep.log"
          fi

          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          FALLBACK="manual-${SHORT_SHA}"
          FINAL_REL_TAG="$FALLBACK"

          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.release_tag }}" ]]; then
            FINAL_REL_TAG="${{ github.event.inputs.release_tag }}"
          elif [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            FINAL_REL_TAG="${GITHUB_REF##refs/tags/}"
          fi

          echo "release_tag_final=$FINAL_REL_TAG" >> $GITHUB_OUTPUT
          echo "FINAL_RELEASE_TAG=$FINAL_REL_TAG" | tee -a "${LOG_DIR}/30_release_prep.log"

      - name: Upload release prep logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: defenderbot-release-prep-step
          path: |
            ${{ env.LOG_DIR }}/30_release_prep.log
            ${{ env.LOG_DIR }}/.keep
            ${{ env.DIST_DIR }}/*.jar
            ${{ env.DIST_DIR }}/*.sha256
            ${{ env.DIST_DIR }}/.keep
          if-no-files-found: warn

      - name: Create / Update GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_prep.outputs.release_tag_final }}
          name: DefenderBot ${{ steps.release_prep.outputs.release_tag_final }}
          draft: false
          prerelease: false
          files: |
            ${{ env.DIST_DIR }}/*.jar
            ${{ env.DIST_DIR }}/*.sha256
        continue-on-error: true

      ########################################################################
      # 5. Remote Upgrade (ssh-agent 없이, soft-pass / 러너상태 재기록)
      ########################################################################
      - name: Install SSH client
        shell: bash
        run: |
          set -Eeuo pipefail
          sudo apt-get update -y
          sudo apt-get install -y openssh-client || true
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep
          echo "[OK] ssh client ready" | tee "${LOG_DIR}/40_upgrade_sshclient.log"

          # 업그레이드 직전 러너 snapshot (배포 타이밍의 시스템 상태)
          {
            echo "=== RUNNER SNAPSHOT (BEFORE REMOTE UPGRADE) ==="
            uname -a || true
            df -h || true
            free -m || true
            docker ps -a || true
            docker images || true
          } | tee "${LOG_DIR}/40b_runner_snapshot_pre_upgrade.log"

      - name: Compute upgrade enable & tag
        id: upgrade_calc
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

          UPG_REQ="false"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.upgrade }}" == "true" ]]; then
            UPG_REQ="true"
          fi

          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          FINAL_TAG="sha-${SHORT_SHA}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.image_tag }}" ]]; then
            FINAL_TAG="${{ github.event.inputs.image_tag }}"
          fi

          echo "upgrade_request=$UPG_REQ" >> $GITHUB_OUTPUT
          echo "deploy_tag=$FINAL_TAG" >> $GITHUB_OUTPUT

          {
            echo "UPGRADE_REQUEST=$UPG_REQ"
            echo "DEPLOY_TAG=$FINAL_TAG"
          } | tee "${LOG_DIR}/41_upgrade_calc.log"

      - name: Register known_hosts (if host provided)
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p ~/.ssh
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

          if [[ -n "${{ secrets.SERVER_HOST }}" ]]; then
            ssh-keyscan -H "${{ secrets.SERVER_HOST }}" >> ~/.ssh/known_hosts || true
            echo "known_hosts updated for ${{ secrets.SERVER_HOST }}" | tee "${LOG_DIR}/42_known_hosts.log"
          else
            echo "[WARN] SERVER_HOST secret missing, will not SSH" | tee "${LOG_DIR}/42_known_hosts.log"
          fi

      - name: Remote pull & restart container
        shell: bash
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

          echo ">>> REMOTE UPGRADE STEP"          | tee "${LOG_DIR}/43_remote_upgrade.log"
          echo "SERVER_HOST=${SERVER_HOST}"      | tee -a "${LOG_DIR}/43_remote_upgrade.log"
          echo "SERVER_USER=${SERVER_USER}"      | tee -a "${LOG_DIR}/43_remote_upgrade.log"

          if [[ "${{ steps.upgrade_calc.outputs.upgrade_request }}" != "true" ]]; then
            echo "[INFO] upgrade_request != true, soft-pass" | tee -a "${LOG_DIR}/43_remote_upgrade.log"
            exit 0
          fi
          if [[ -z "${SERVER_HOST}" || -z "${SERVER_USER}" || -z "${GITHUB_TOKEN}" ]]; then
            echo "[WARN] Missing SERVER_HOST / SERVER_USER / GITHUB_TOKEN -> cannot SSH deploy. soft-pass." | tee -a "${LOG_DIR}/43_remote_upgrade.log"
            exit 0
          fi

          IMG_TAG="${{ steps.upgrade_calc.outputs.deploy_tag }}"
          REMOTE_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMG_TAG}"
          echo "[INFO] Using remote image ${REMOTE_IMAGE}" | tee -a "${LOG_DIR}/43_remote_upgrade.log"

          # ssh-agent 없이 기본 ssh 키만 사용.
          ssh -o StrictHostKeyChecking=yes "${SERVER_USER}@${SERVER_HOST}" bash -lc "
            set -Eeuo pipefail
            echo '--- Remote Upgrade Script Started ---'

            echo \"\$GITHUB_TOKEN\" | docker login ${{ env.REGISTRY }} -u '${{ github.actor }}' --password-stdin || true

            echo 'Pulling image: ${REMOTE_IMAGE}'
            docker pull ${REMOTE_IMAGE} || true

            echo 'Stopping existing container if exists'
            docker rm -f ${{ env.CONTAINER_NAME }} 2>/dev/null || true

            echo 'Starting new container'
            docker run -d --name ${{ env.CONTAINER_NAME }} \
              -p ${{ env.HOST_PORT }}:${{ env.CONTAINER_PORT }} \
              --restart unless-stopped \
              ${REMOTE_IMAGE} || true

            echo '--- Remote Upgrade Script Finished ---'
          " || true

      - name: Upload upgrade logs/artifacts snapshot
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: defenderbot-upgrade-step
          path: |
            ${{ env.LOG_DIR }}/40_upgrade_sshclient.log
            ${{ env.LOG_DIR }}/40b_runner_snapshot_pre_upgrade.log
            ${{ env.LOG_DIR }}/41_upgrade_calc.log
            ${{ env.LOG_DIR }}/42_known_hosts.log
            ${{ env.LOG_DIR }}/43_remote_upgrade.log
            ${{ env.LOG_DIR }}/.keep
          if-no-files-found: warn

      ########################################################################
      # 6. FINAL PIPELINE SNAPSHOT (전체 수집)
      ########################################################################
      - name: Final snapshot & upload all
        if: always()
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${ARTIFACT_DIR}" "${DIST_DIR}" target
          touch "${LOG_DIR}/.keep" "${ARTIFACT_DIR}/.keep" "${DIST_DIR}/.keep" target/.keep

          # 파이프라인 종료 로그
          echo "[`date '+%Y-%m-%d %H:%M:%S%z'`] pipeline.end (ALL STEPS ATTEMPTED)" \
            | tee "${LOG_DIR}/99_pipeline_end.log"

          # 마지막 러너 상태 한 번 더 캡처
          {
            echo "=== RUNNER SNAPSHOT (FINAL) ==="
            uname -a || true
            df -h || true
            free -m || true
            docker ps -a || true
            docker images || true
          } | tee "${LOG_DIR}/98_runner_snapshot_final.log"

      - name: Upload ALL logs/final snapshot
        if: always()
        uses: actions/upload-artifact@v5
        with:
          name: defenderbot-full-run
          path: |
            ${{ env.LOG_DIR }}/
            ${{ env.ARTIFACT_DIR }}/
            ${{ env.DIST_DIR }}/
            target/
          if-no-files-found: warn
