name: "ğŸ§ All-in-One CI/CD Pipeline (Stabilized) â€” EchoOps"

# 1. íŠ¸ë¦¬ê±° ì„¤ì •
on:
  push:
    branches: [ main, master, '**/create-and-manage-linux-images**' ]
    tags: 
      - 'v[0-9]+.[0-9]+.[0-9]+'
  pull_request:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy (e.g., latest or v1.0.0)'
        required: false
        default: 'latest'
      environment:
        description: 'Deployment environment'
        required: false
        default: 'Staging'
        type: choice
        options:
          - Staging
          - Production
          
permissions:
  contents: read
  packages: write 
  id-token: write
  deployments: write

env:
  REGISTRY: ghcr.io
  ECHO_PREFIX: "[EchoOps][CI/CD]"

jobs:
  # 1. ì´ë¯¸ì§€ ë¹Œë“œ, ë³´ì•ˆ ê²€ì¦ ë° í‘¸ì‹œ
  build-and-push:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 5
      fail-fast: false
      matrix: # ìŠ¤í‚µ ì—†ì´ ëª¨ë“  í•­ëª© ë¬´ì¡°ê±´ ì‹¤í–‰
        include:
          - name: ubuntu
            context: ./docker/ubuntu
            dockerfile: ./docker/ubuntu/Dockerfile
          - name: ubi
            context: ./docker/ubi
            dockerfile: ./docker/ubi/Dockerfile
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Set up Multi-Arch Tools (QEMU & Buildx)
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all
      - uses: docker/setup-buildx-action@v3
        
      # HadolintëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí•´ë„ ë¹Œë“œë¥¼ ê³„ì† ì§„í–‰í•˜ë„ë¡ ì„¤ì • ìœ ì§€ (Dockerfile ìˆ˜ì • ê¶Œì¥)
      - name: Lint Dockerfile (Hadolint)
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: ${{ matrix.dockerfile }}
          failure-threshold: warning # warning ì´ìƒ ì‹œ ì—ëŸ¬ ë°œìƒ
        continue-on-error: true # ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ ì›Œí¬í”Œë¡œìš°ëŠ” ê³„ì† ì§„í–‰
          
      - name: Prepare Image Metadata & Tags
        id: meta
        run: |
          IMAGE_NAME="${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ matrix.name }}"
          SHA_TAG="${IMAGE_NAME}:sha-${GITHUB_SHA}}"
          TAGS="${SHA_TAG}"
          
          if [[ "${GITHUB_REF_NAME}" == "main" ]]; then
            TAGS="${TAGS},${IMAGE_NAME}:latest"
          fi
          if [[ "${GITHUB_REF_TYPE:-}" == "tag" ]]; then
            TAGS="${TAGS},${IMAGE_NAME}:${GITHUB_REF_NAME}"
          fi
          
          # Load/Push ì •ì±… ì„¤ì • (Multi-Arch ì˜¤ë¥˜ í•´ê²°ì„ ìœ„í•œ í•µì‹¬ ë¡œì§)
          if [[ "${GITHUB_EVENT_NAME}" == "pull_request" ]]; then
            echo "::set-output name=PUSH_MODE::false"
            echo "::set-output name=LOAD_MODE::true"
            echo "::set-output name=BUILD_PLATFORMS::linux/amd64" # PRì€ ë‹¨ì¼ ì•„í‚¤í…ì²˜ë§Œ ë¡œë“œ
          else
            echo "::set-output name=PUSH_MODE::true"
            echo "::set-output name=LOAD_MODE::false"
            echo "::set-output name=BUILD_PLATFORMS::linux/amd64,linux/arm64" # PushëŠ” Multi-Arch í‘¸ì‹œ
          fi

          echo "image_sha_tag=${SHA_TAG}" >> "$GITHUB_OUTPUT"
          echo "image_tags=${TAGS}" >> "$GITHUB_OUTPUT"
          echo "PUSH_MODE=${PUSH_MODE}" >> "$GITHUB_OUTPUT"
          echo "LOAD_MODE=${LOAD_MODE}" >> "$GITHUB_OUTPUT"
          echo "BUILD_PLATFORMS=${BUILD_PLATFORMS}" >> "$GITHUB_OUTPUT"


      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      # 2. Build and Push (Multi-Arch ì˜¤ë¥˜ í•´ê²° ë¡œì§ ì ìš©)
      - name: Build and Push Image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          # PRê³¼ Push ì´ë²¤íŠ¸ì— ë”°ë¼ í”Œë«í¼, Load, Push ëª¨ë“œ ë¶„ë¦¬
          platforms: ${{ steps.meta.outputs.BUILD_PLATFORMS }}
          push: ${{ steps.meta.outputs.PUSH_MODE }}
          load: ${{ steps.meta.outputs.LOAD_MODE }}
          tags: ${{ steps.meta.outputs.image_tags }}
          cache-from: type=gha,type=registry,ref=${{ env.REGISTRY }}/${{ github.repository_owner }}/buildcache:${{ matrix.name }}
          cache-to: type=gha,type=registry,ref=${{ env.REGISTRY }}/${{ github.repository_owner }}/buildcache:${{ matrix.name }},mode=max

      # 3. Smoke Test (PR ì‹œ Load ëª¨ë“œì—ì„œë§Œ ì‹¤í–‰ ê°€ëŠ¥)
      - name: Smoke Test Image (Only on Load Mode)
        if: steps.meta.outputs.LOAD_MODE == 'true'
        run: |
          IMAGE="${{ steps.meta.outputs.image_sha_tag }}"
          echo "${{ env.ECHO_PREFIX}} Running smoke test on loaded image: ${IMAGE}"
          docker run --rm "${IMAGE}" bash -lc "
            test -f /etc/app/permissions.conf;
            test -d /opt/app/data;
            test -d /var/log/app;
            echo 'Smoke test passed.';
          "
          
      # 4. Trivy Security Gate ë° SBOM ìƒì„±
      - name: Scan Image for Vulnerabilities (Trivy Security Gate)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ steps.meta.outputs.image_sha_tag }}
          format: table
          severity: CRITICAL,HIGH 
          exit-code: 1 
          ignore-unfixed: true
          
      - name: Generate and Upload SBOM (CycloneDX)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ steps.meta.outputs.image_sha_tag }}
          format: cyclonedx
          output: sbom-${{ matrix.name }}.json
          scan-type: image
          
      - name: Upload SBOM Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}-sbom-${{ github.run_number }}
          path: sbom-${{ matrix.name }}.json
          retention-days: 30 

      # 5. ì•„í‹°íŒ©íŠ¸ ì €ì¥ ë° ë°±ì—…
      - name: Save Image and Upload to Artifacts (Short-term)
        # Load ëª¨ë“œì¼ ë•Œë§Œ docker save ê°€ëŠ¥
        if: steps.meta.outputs.LOAD_MODE == 'true'
        run: |
          IMAGE="${{ steps.meta.outputs.image_sha_tag }}"
          TAR_NAME="${{ matrix.name }}.tar.gz"
          docker save "${IMAGE}" | gzip > "${TAR_NAME}"
      - name: Upload Image Artifact
        if: steps.meta.outputs.LOAD_MODE == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}-image-${{ github.run_number }}
          path: ${{ matrix.name }}.tar.gz
          retention-days: 7

      - name: Long-term Image Backup to Cloud Storage
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
        # ì´ ìŠ¤í…ì€ ì‹¤ì œ S3, GCS ì—…ë¡œë“œ ìŠ¤í¬ë¦½íŠ¸/ì•¡ì…˜ìœ¼ë¡œ ëŒ€ì²´ë˜ì–´ì•¼ í•¨
        run: |
          echo "${{ env.ECHO_PREFIX}} Backing up ${{ matrix.name }}.tar.gz to S3/GCS..."
          # aws s3 cp ${{ matrix.name }}.tar.gz s3://${{ secrets.BACKUP_BUCKET }}/artifacts/

  # 6. ìŠ¤í…Œì´ì§• ë°°í¬ (ë¹Œë“œ ì„±ê³µ ì‹œ ë¬´ì¡°ê±´ ì‹¤í–‰)
  deploy-staging:
    needs: [build-and-push]
    if: |
      success() && (
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/'))) || 
        (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'Staging')
      )
    runs-on: ubuntu-latest
    environment: Staging 
    steps:
      - name: Determine Image Tag
        id: tag
        run: |
          TAG='${{ github.sha }}'
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAG='latest'
          elif [[ "${{ github.event_name }}" == "push" && startsWith("${{ github.ref }}", "refs/tags/") ]]; then
            TAG="${{ github.ref_name }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TAG="${{ github.event.inputs.image_tag }}"
          fi
          echo "DEPLOY_TAG=${TAG}" >> "$GITHUB_OUTPUT"

      - name: Deploy Image to Staging Environment
        # ë°°í¬ ëª…ë ¹ì–´ëŠ” ì‚¬ìš©ìì˜ ì¸í”„ë¼ì— ë§ê²Œ ìˆ˜ì • í•„ìš”
        run: |
          echo "${{ env.ECHO_PREFIX}} Deploying ${{ steps.tag.outputs.DEPLOY_TAG }} to Staging."
          # kubectl set image deployment/app-staging app-container=${{ env.REGISTRY }}/${{ github.repository_owner }}/app:${{ steps.tag.outputs.DEPLOY_TAG }}

  # 7. ìš´ì˜ í™˜ê²½ ë°°í¬ (ìˆ˜ë™ ìŠ¹ì¸ í¬í•¨)
  deploy-production:
    needs: [deploy-staging]
    if: |
      success() && (
        (github.event_name == 'push' && (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/'))) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'Production')
      )
    runs-on: ubuntu-latest
    environment: 
      name: Production 
      url: https://your-production-url.com
    steps:
      - name: Determine Image Tag
        id: tag
        run: |
          TAG='${{ github.sha }}'
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
            TAG='latest'
          elif [[ "${{ github.event_name }}" == "push" && startsWith("${{ github.ref }}", "refs/tags/") ]]; then
            TAG="${{ github.ref_name }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TAG="${{ github.event.inputs.image_tag }}"
          fi
          echo "DEPLOY_TAG=${TAG}" >> "$GITHUB_OUTPUT"

      - name: Deploy Image to Production Environment
        # ë°°í¬ ëª…ë ¹ì–´ëŠ” ì‚¬ìš©ìì˜ ì¸í”„ë¼ì— ë§ê²Œ ìˆ˜ì • í•„ìš”
        run: |
          echo "${{ env.ECHO_PREFIX}} Deploying ${{ steps.tag.outputs.DEPLOY_TAG }} to Production."
          # kubectl set image deployment/app-prod app-container=${{ env.REGISTRY }}/${{ github.repository_owner }}/app:${{ steps.tag.outputs.DEPLOY_TAG }}
          
      - name: Scale up Server Replicas
        # ì„œë²„ ì„¤ì¹˜ ì¦ê°€/í™•ì¥ ë¡œì§
        run: |
          echo "${{ env.ECHO_PREFIX}} Scaling up deployment to desired capacity (e.g., 5 replicas)."
          # kubectl scale deployment app-prod --replicas=5
