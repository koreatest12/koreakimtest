name: "🔄 Concurrency Control + Runner Self-Heal + Auto-Retry"

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

concurrency:
  # 같은 브랜치/같은 워크플로우 안에서는 항상 최신 실행만 남기고
  # 이전 실행(진행 중/대기 중)은 취소
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  TZ: Asia/Seoul
  LOG_DIR: .github/echo_logs
  REPORT_DIR: .github/echo_report

jobs:
  ##########################################################################
  # 0. 러너 상태 점검 & 청소
  #    - 디스크/메모리 사용률, docker 잔재, 캐시 등 점검
  #    - 가능하면 정리해서 "러너가 꽉 차서 죽는 상황"을 완화
  ##########################################################################
  prep_and_clean:
    name: "Runner Pre-Check / Cleanup"
    runs-on: ubuntu-latest
    continue-on-error: true
    outputs:
      disk_ok: ${{ steps.check.outputs.disk_ok }}
      mem_ok:  ${{ steps.check.outputs.mem_ok }}
    steps:
      - name: Prep dirs
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${REPORT_DIR}"
          touch "${LOG_DIR}/.keep" "${REPORT_DIR}/.keep"

      - name: Runner snapshot (before cleanup)
        shell: bash
        run: |
          set -Eeuo pipefail
          {
            echo "=== RUNNER SNAPSHOT (BEFORE CLEANUP) ==="
            echo "--- uname -a"
            uname -a || true
            echo
            echo "--- df -h"
            df -h || true
            echo
            echo "--- free -m"
            free -m || true
            echo
            echo "--- docker ps -a"
            docker ps -a || true
            echo
            echo "--- docker images"
            docker images || true
            echo
          } | tee "${LOG_DIR}/00_runner_snapshot_before.txt"

      - name: Cleanup docker/junk to free resources
        shell: bash
        run: |
          set -Eeuo pipefail
          echo ">>> docker system prune -af (safe cleanup)" | tee "${LOG_DIR}/01_cleanup.txt"
          docker system prune -af || true
          docker volume prune -f || true
          echo ">>> apt-get clean / autoremove" | tee -a "${LOG_DIR}/01_cleanup.txt"
          sudo apt-get clean || true
          sudo apt-get autoremove -y || true

      - name: Check resources after cleanup
        id: check
        shell: bash
        run: |
          set -Eeuo pipefail

          # 기본 임계값 - 디스크 여유 2GB 이상, 메모리 여유 512MB 이상 있으면 OK로 간주
          DISK_AVAIL_GB=$(df -BG / | awk 'NR==2 {gsub("G","",$4); print $4}')
          MEM_FREE_MB=$(free -m | awk '/Mem:/ {print $4}')

          DISK_OK="true"
          MEM_OK="true"
          if [ "$DISK_AVAIL_GB" -lt 2 ]; then
            DISK_OK="false"
          fi
          if [ "$MEM_FREE_MB" -lt 512 ]; then
            MEM_OK="false"
          fi

          echo "disk_ok=$DISK_OK" >> $GITHUB_OUTPUT
          echo "mem_ok=$MEM_OK" >> $GITHUB_OUTPUT

          {
            echo "=== RESOURCE CHECK (AFTER CLEANUP) ==="
            echo "DISK_AVAIL_GB=$DISK_AVAIL_GB"
            echo "DISK_OK=$DISK_OK"
            echo "MEM_FREE_MB=$MEM_FREE_MB"
            echo "MEM_OK=$MEM_OK"
          } | tee "${LOG_DIR}/02_resource_check_after.txt"

      - name: Upload runner-prep logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: runner-prep
          path: |
            ${{ env.LOG_DIR }}/00_runner_snapshot_before.txt
            ${{ env.LOG_DIR }}/01_cleanup.txt
            ${{ env.LOG_DIR }}/02_resource_check_after.txt
            ${{ env.LOG_DIR }}/.keep
          if-no-files-found: warn

  ##########################################################################
  # 1. 실제 작업 1차 시도
  ##########################################################################
  job_attempt_1:
    name: "Build & Test (Attempt 1)"
    runs-on: ubuntu-latest
    needs: prep_and_clean
    continue-on-error: true   # 실패해도 워크플로우는 계속 진행
    outputs:
      attempt1_status: ${{ steps.mark.outputs.attempt1_status }}
    steps:
      - name: Prep dirs
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${REPORT_DIR}"
          touch "${LOG_DIR}/.keep" "${REPORT_DIR}/.keep"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Runner snapshot (attempt1 start)
        shell: bash
        run: |
          set -Eeuo pipefail
          {
            echo "=== RUNNER SNAPSHOT (ATTEMPT 1 START) ==="
            df -h || true
            free -m || true
            docker ps -a || true
          } | tee "${LOG_DIR}/10_snapshot_attempt1_start.txt"

      - name: Build/Test main logic
        id: buildtest
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "⚙ Attempt #1 running on ${{ github.ref }} (commit ${{ github.sha }})" \
            | tee "${LOG_DIR}/11_attempt1_run.txt"

          # 여기서 실제 빌드/테스트 로직을 넣으면 됩니다.
          # 예: maven 빌드, npm ci && npm test, docker build 등
          # 지금은 예시로 일부러 긴 작업 흉내:
          echo "Simulating heavy workload..."
          sleep 60

          echo "Attempt #1 work finished." | tee -a "${LOG_DIR}/11_attempt1_run.txt"

      - name: Mark attempt1 status
        id: mark
        shell: bash
        run: |
          set -Eeuo pipefail
          # 여기서는 간단히 "success"로 남기지만,
          # 실제로는 위 단계가 실패했는지 $?를 체크해서 기록할 수 있습니다.
          # 예: if [ "${{ steps.buildtest.outcome }}" != "success" ]; then ...
          # GitHub Actions에서 outcome을 직접 변수로 못쓰니, try/catch 패턴으로 캡처하려면
          # 위 build/test 단계에서 종료코드 관리하면 됩니다.
          # 현재는 0으로 종료했으므로 success
          STATUS="success"
          echo "attempt1_status=$STATUS" >> $GITHUB_OUTPUT
          echo "attempt1_status=$STATUS" | tee "${LOG_DIR}/12_attempt1_status.txt"

      - name: Upload attempt1 logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: attempt1-logs
          path: |
            ${{ env.LOG_DIR }}/10_snapshot_attempt1_start.txt
            ${{ env.LOG_DIR }}/11_attempt1_run.txt
            ${{ env.LOG_DIR }}/12_attempt1_status.txt
            ${{ env.LOG_DIR }}/.keep
          if-no-files-found: warn

  ##########################################################################
  # 2. 자동 재시도 (Attempt 2)
  #    - Attempt 1이 "실패"일 때만 실행하도록 설계
  #    - 여기서는 attempt1_status != success 일 때만 실행되도록 조건부 처리
  #    - 위 예시는 항상 success로 마킹되어 있어서 실제로는 실행 안 될 것.
  ##########################################################################
  job_attempt_2:
    name: "Build & Test (Attempt 2 / Self-Heal Retry)"
    runs-on: ubuntu-latest
    needs: [prep_and_clean, job_attempt_1]
    if: ${{ needs.job_attempt_1.outputs.attempt1_status != 'success' }}
    continue-on-error: true
    steps:
      - name: Prep dirs
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${REPORT_DIR}"
          touch "${LOG_DIR}/.keep" "${REPORT_DIR}/.keep"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Runner snapshot (attempt2 start)
        shell: bash
        run: |
          set -Eeuo pipefail
          {
            echo "=== RUNNER SNAPSHOT (ATTEMPT 2 START) ==="
            df -h || true
            free -m || true
            docker ps -a || true
          } | tee "${LOG_DIR}/20_snapshot_attempt2_start.txt"

      - name: Build/Test retry logic
        shell: bash
        run: |
          set -Eeuo pipefail
          echo "⚠ Attempt #2 retry due to resource or previous failure" \
            | tee "${LOG_DIR}/21_attempt2_run.txt"

          # 재시도 로직 (동일 빌드/테스트 다시 실행)
          # 예시: sleep 으로 시뮬레이션
          echo "Retrying heavy workload..."
          sleep 60

          echo "Attempt #2 finished." | tee -a "${LOG_DIR}/21_attempt2_run.txt"

      - name: Upload attempt2 logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: attempt2-logs
          path: |
            ${{ env.LOG_DIR }}/20_snapshot_attempt2_start.txt
            ${{ env.LOG_DIR }}/21_attempt2_run.txt
            ${{ env.LOG_DIR }}/.keep
          if-no-files-found: warn

  ##########################################################################
  # 3. 최종 리포트/스냅샷 업로드
  #    - prep_and_clean, attempt_1, attempt_2 (조건부) 실행 결과를 종합
  #    - 항상 실행해서 최종 상태 추적 가능
  ##########################################################################
  final_report:
    name: "Final Report / Collected Evidence"
    runs-on: ubuntu-latest
    needs:
      - prep_and_clean
      - job_attempt_1
      - job_attempt_2
    if: always()
    steps:
      - name: Prep dirs
        shell: bash
        run: |
          set -Eeuo pipefail
          mkdir -p "${LOG_DIR}" "${REPORT_DIR}"
          touch "${LOG_DIR}/.keep" "${REPORT_DIR}/.keep"

          {
            echo "=== FINAL SUMMARY ==="
            echo "event_name=${{ github.event_name }}"
            echo "ref=${{ github.ref }}"
            echo "sha=${{ github.sha }}"
            echo "actor=${{ github.actor }}"
            echo
            echo "prep_and_clean.disk_ok=${{ needs.prep_and_clean.outputs.disk_ok }}"
            echo "prep_and_clean.mem_ok=${{ needs.prep_and_clean.outputs.mem_ok }}"
            echo
            echo "attempt1_status=${{ needs.job_attempt_1.outputs.attempt1_status }}"
            echo "(attempt2 ran? -> ${{ needs.job_attempt_2.result }})"
            echo
            date
          } | tee "${REPORT_DIR}/final_summary.txt"

      - name: Upload final bundle
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: final-summary-and-logs
          path: |
            ${{ env.LOG_DIR }}/
            ${{ env.REPORT_DIR }}/
          if-no-files-found: warn
