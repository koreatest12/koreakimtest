name: "Force Cancel Stuck Workflow Runs"

on:
  workflow_dispatch:
    inputs:
      workflow:
        description: "Workflow file name or ID (empty or 'all' = scan all workflows in repo)"
        required: false
        default: "all"
        type: string
      max_run_minutes:
        description: "Maximum allowed run time in minutes before cancellation (empty = 60)"
        required: false
        default: "60"
        type: string
      status_filter:
        description: "Comma-separated list of statuses to target (queued,in_progress)"
        default: "queued,in_progress"
        type: string
      run_id:
        description: "Optional specific run ID to cancel (if valid positive integer, this run is cancelled first)"
        required: false
        type: string
      dry_run:
        description: "If true, only report runs that would be cancelled"
        type: boolean
        required: false
        default: true

permissions:
  actions: write
  contents: read

jobs:
  force-cancel:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    # workflow_dispatch 입력 → env로 고정 연결
    env:
      WORKFLOW_INPUT: ${{ github.event.inputs.workflow }}
      MAX_RUN_MINUTES_INPUT: ${{ github.event.inputs.max_run_minutes }}
      STATUS_FILTER_INPUT: ${{ github.event.inputs.status_filter }}
      RUN_ID_INPUT: ${{ github.event.inputs.run_id }}
      DRY_RUN_INPUT: ${{ github.event.inputs.dry_run }}

    steps:
      - name: Validate inputs & prepare flags
        id: validate
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // ----- max_run_minutes 처리 -----
            const rawMax = (process.env.MAX_RUN_MINUTES_INPUT || '').trim();
            const effectiveMax = rawMax === '' ? '60' : rawMax;
            const maxRunMinutes = Number(effectiveMax);

            if (!Number.isFinite(maxRunMinutes) || maxRunMinutes <= 0) {
              core.setFailed(`max_run_minutes must be a positive number, received: ${rawMax}`);
              return;
            }
            core.setOutput('max_run_minutes', String(maxRunMinutes));

            // ----- workflow / run_id 처리 -----
            const workflowRaw = (process.env.WORKFLOW_INPUT || '').trim();
            const runIdRaw = (process.env.RUN_ID_INPUT || '').trim();

            // ----- dry_run 문자열 파싱 (YAML boolean 에러 방지) -----
            const dryRunRaw = (process.env.DRY_RUN_INPUT ?? 'true').toString().trim();
            const dryRunNorm = dryRunRaw.toLowerCase();
            const dryRun =
              dryRunNorm === 'true' ||
              dryRunNorm === '1' ||
              dryRunNorm === 'yes' ||
              dryRunNorm === 'y' ||
              dryRunNorm === 'on';
            core.setOutput('dry_run', dryRun ? 'true' : 'false');

            // ----- 단일 run 취소 플래그 처리 -----
            let hasSingle = false;
            if (runIdRaw !== '') {
              if (/^[0-9]+$/.test(runIdRaw)) {
                const numericRunId = Number(runIdRaw);
                if (Number.isInteger(numericRunId) && numericRunId > 0) {
                  hasSingle = true;
                  core.setOutput('target_run_id', String(numericRunId));
                  core.info(`Single-run cancel enabled (run_id=${numericRunId})`);
                } else {
                  core.info(`run_id "${runIdRaw}" is not a positive integer. Ignoring for single-run cancel.`);
                }
              } else {
                core.info(`run_id "${runIdRaw}" is not numeric (e.g., "all"). Ignoring for single-run cancel.`);
              }
            }
            core.setOutput('has_single', hasSingle ? 'true' : 'false');

            // ----- 스캔 스코프 결정 -----
            let scanScope = 'repo'; // 기본: 레포 전체
            if (workflowRaw && workflowRaw.toLowerCase() !== 'all') {
              scanScope = 'workflow';
              core.setOutput('workflow_id', workflowRaw);
              core.info(`Scan scope: only workflow "${workflowRaw}"`);
            } else {
              core.info('Scan scope: ALL workflows in repository');
            }
            core.setOutput('scan_scope', scanScope);

      - name: Force cancel specific run (if valid run_id)
        if: steps.validate.outputs.has_single == 'true'
        uses: actions/github-script@v7
        env:
          DRY_RUN_FLAG: ${{ steps.validate.outputs.dry_run }}
          TARGET_RUN_ID: ${{ steps.validate.outputs.target_run_id }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const dryRun = (process.env.DRY_RUN_FLAG || 'true').toLowerCase() === 'true';
            const runId = process.env.TARGET_RUN_ID;

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const url = `https://github.com/${owner}/${repo}/actions/runs/${runId}`;

            core.info(`=== Single-run cancel section ===`);
            core.info(`Target run_id: ${runId}`);
            core.info(`Dry run: ${dryRun}`);

            if (dryRun) {
              core.info(`[Dry Run] Would cancel ${url}`);
              return;
            }

            await github.rest.actions.cancelWorkflowRun({
              owner,
              repo,
              run_id: Number(runId),
            });

            core.info(`Cancelled ${url}`);

      - name: Scan & force cancel stuck workflows (repo/workflow)
        uses: actions/github-script@v7
        env:
          EFFECTIVE_MAX_RUN_MINUTES: ${{ steps.validate.outputs.max_run_minutes }}
          SCAN_SCOPE: ${{ steps.validate.outputs.scan_scope }}
          WORKFLOW_ID: ${{ steps.validate.outputs.workflow_id }}
          STATUS_FILTER: ${{ env.STATUS_FILTER_INPUT }}
          DRY_RUN_FLAG: ${{ steps.validate.outputs.dry_run }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const maxRunMinutes = Number(process.env.EFFECTIVE_MAX_RUN_MINUTES);
            const scanScope = process.env.SCAN_SCOPE || 'repo';
            const workflowId = process.env.WORKFLOW_ID;
            const dryRun = (process.env.DRY_RUN_FLAG || 'true').toLowerCase() === 'true';

            const statusFilterStr = (process.env.STATUS_FILTER || '').trim();
            const statusFilter = (statusFilterStr || 'queued,in_progress')
              .split(',')
              .map((s) => s.trim())
              .filter(Boolean);

            if (statusFilter.length === 0) {
              core.setFailed('status_filter must include at least one status');
              return;
            }

            const thresholdMillis = maxRunMinutes * 60 * 1000;
            const now = Date.now();
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const fetchedRuns = [];

            core.info(`=== Scan & cancel section ===`);
            core.info(`Scan scope: ${scanScope === 'workflow' ? `workflow "${workflowId}"` : `ALL workflows in ${owner}/${repo}`}`);
            core.info(`Max run minutes: ${maxRunMinutes}`);
            core.info(`Dry run: ${dryRun}`);
            core.info(`Status filter: ${statusFilter.join(', ')}`);

            for (const status of statusFilter) {
              if (scanScope === 'workflow') {
                core.info(`Fetching runs for workflow "${workflowId}" with status "${status}"...`);
                const runs = await github.paginate(
                  github.rest.actions.listWorkflowRuns,
                  {
                    owner,
                    repo,
                    workflow_id: workflowId,
                    per_page: 100,
                    status,
                  }
                );
                fetchedRuns.push(...runs);
              } else {
                core.info(`Fetching runs for ALL workflows in ${owner}/${repo} with status "${status}"...`);
                const runs = await github.paginate(
                  github.rest.actions.listWorkflowRunsForRepo,
                  {
                    owner,
                    repo,
                    per_page: 100,
                    status,
                  }
                );
                fetchedRuns.push(...runs);
              }
            }

            if (fetchedRuns.length === 0) {
              core.info('No workflow runs matched the given filters.');
              return;
            }

            const targets = fetchedRuns.filter((run) => {
              const createdAt = new Date(run.created_at).getTime();
              const age = now - createdAt;
              return age >= thresholdMillis;
            });

            if (targets.length === 0) {
              core.info('No workflow runs exceeded the maximum runtime threshold.');
              return;
            }

            core.info(
              `Identified ${targets.length} workflow run(s) exceeding ${maxRunMinutes} minutes (scope=${scanScope}).`
            );

            for (const run of targets) {
              const ageMinutes = ((now - new Date(run.created_at).getTime()) / 60000).toFixed(1);
              const url = `https://github.com/${owner}/${repo}/actions/runs/${run.id}`;
              const wfName = run.name || '(no name)';

              core.info(
                `Run ${run.id} (${wfName}) has been running for ~${ageMinutes} minutes [status=${run.status}].`
              );

              if (dryRun) {
                core.info(`[Dry Run] Would cancel ${url}`);
                continue;
              }

              await github.rest.actions.cancelWorkflowRun({
                owner,
                repo,
                run_id: run.id,
              });

              core.info(`Cancelled ${url}`);
            }
